# DO NOT EDIT THIS FILE
# This file is generated from:
# https://github.com/Spruked/UCM_Worker_Template
# Any modifications must be made in the GitHub source, not here.

import json
import time
import asyncio
import httpx
from fastapi import FastAPI, HTTPException, APIRouter
from typing import Dict, Any, Optional
import nacl.signing
import nacl.exceptions


class WorkerTemplate:
    """
    Golden template for generating workers in the DALS ecosystem.
    Provides a complete, production-ready structure for worker instances.

    This template is injected by DALS with:
    - serial number
    - model ID
    - glyph trace
    - accountability vault
    - reflection vault
    - posterior/AP Helix reference ID
    - UCM plugin pipe
    """

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.serial = config.get("worker_serial", "TEMPLATE-000")
        self.model_id = config.get("model_id", "000-0000000000")
        self.glyph_trace = config.get("glyph_trace", "")
        self.accountability_vault = config.get("accountability_vault", {})
        self.reflection_vault = config.get("reflection_vault", {})
        self.ap_helix_ref = config.get("ap_helix_ref", "")
        self.ucm_plugin_pipe = config.get("ucm_plugin_pipe", "")

        # Initialize FastAPI app
        self.app = FastAPI(title=f"Worker-{self.serial}")
        self.pem_engine = None  # Injected by DALS

        # Setup routes
        self._setup_routes()

        # Vault integration
        self._setup_vault_integration()

    def _setup_routes(self):
        """Setup FastAPI routes"""
        router = APIRouter()

        @router.post("/task")
        async def process_task(envelope: dict):
            """Process a task envelope from UCM"""
            # Verify envelope using injected UCM key
            ucm_key = self._get_ucm_public_key()
            ok, msg = self._verify_envelope(envelope, ucm_key)
            if not ok:
                raise HTTPException(status_code=403, detail=f"Invalid task envelope: {msg}")

            task = envelope["payload"]
            result = await self._execute_task(task)
            return {"result": result, "worker_serial": self.serial}

        @router.get("/")
        def root():
            return {
                "message": f"Worker {self.serial} Active",
                "model_id": self.model_id,
                "status": "operational"
            }

        @router.get("/health")
        def health():
            return {
                "serial": self.serial,
                "model_id": self.model_id,
                "status": "healthy",
                "timestamp": time.time()
            }

        @router.get("/vault/status")
        def vault_status():
            """Report vault integration status"""
            return {
                "accountability_vault": bool(self.accountability_vault),
                "reflection_vault": bool(self.reflection_vault),
                "glyph_trace": bool(self.glyph_trace),
                "ap_helix_ref": bool(self.ap_helix_ref)
            }

        self.app.include_router(router)

    def _setup_vault_integration(self):
        """Setup vault integration points"""
        # These are injected by DALS during worker creation
        pass

    def _get_ucm_public_key(self) -> bytes:
        """Get UCM public key for envelope verification"""
        # This should be injected by DALS
        # For now, return a placeholder
        return b"placeholder_ucm_public_key"

    def _verify_envelope(self, envelope: dict, ucm_public_key: bytes) -> tuple[bool, str]:
        """Verify task envelope signature"""
        required = ["task_id", "signature", "payload", "issued_at", "origin_module", "issued_by"]
        for r in required:
            if r not in envelope:
                return False, f"Missing field: {r}"

        # Extract signature + remove before verification
        signature = envelope["signature"]
        unsigned_envelope = envelope.copy()
        del unsigned_envelope["signature"]
        unsigned_bytes = json.dumps(unsigned_envelope, sort_keys=True).encode()

        try:
            verify_key = nacl.signing.VerifyKey(ucm_public_key)
            verify_key.verify(unsigned_bytes, bytes.fromhex(signature))
            return True, "valid"
        except nacl.exceptions.BadSignatureError:
            return False, "INVALID SIGNATURE"

    async def _execute_task(self, task: dict) -> Any:
        """Execute a task using PEM intelligence"""
        task_type = task.get("type")

        # Route to appropriate handler based on task type
        if task_type == "logic_eval":
            return self._logic_eval(task)
        elif task_type == "modus_ponens":
            return self._modus_ponens(task)
        elif task_type == "syllogism":
            return self._syllogism(task)
        elif task_type == "vault_operation":
            return await self._vault_operation(task)
        else:
            return {"message": "Task type not supported", "task_type": task_type}

    def _logic_eval(self, task: dict) -> bool:
        """Basic logic evaluation"""
        if not self.pem_engine:
            return False
        a = task["a"]
        b = task["b"]
        operator = task["operator"]
        return self.pem_engine.evaluate_boolean(a, operator, b)

    def _modus_ponens(self, task: dict) -> bool:
        """Modus ponens logical inference"""
        if not self.pem_engine:
            return False
        return self.pem_engine.modus_ponens(task["premise"], task["implication"])

    def _syllogism(self, task: dict) -> bool:
        """Syllogistic reasoning"""
        if not self.pem_engine:
            return False
        return self.pem_engine.syllogism_lite(task["major"], task["minor"])

    async def _vault_operation(self, task: dict) -> dict:
        """Handle vault operations"""
        operation = task.get("operation")

        if operation == "store_accountability":
            # Store in accountability vault
            key = task.get("key")
            value = task.get("value")
            self.accountability_vault[key] = value
            return {"status": "stored", "vault": "accountability"}

        elif operation == "store_reflection":
            # Store in reflection vault
            key = task.get("key")
            value = task.get("value")
            self.reflection_vault[key] = value
            return {"status": "stored", "vault": "reflection"}

        elif operation == "retrieve_accountability":
            key = task.get("key")
            return {"value": self.accountability_vault.get(key)}

        elif operation == "retrieve_reflection":
            key = task.get("key")
            return {"value": self.reflection_vault.get(key)}

        return {"error": "Unknown vault operation"}

    async def start_heartbeat_loop(self):
        """Start the heartbeat and registration loop"""
        while True:
            try:
                await self._send_heartbeat()
                await asyncio.sleep(self.config.get("heartbeat_interval", 30))
            except Exception as e:
                print(f"Heartbeat error: {e}")
                await asyncio.sleep(5)

    async def _send_heartbeat(self):
        """Send heartbeat to DALS registry"""
        payload = {
            "serial": self.serial,
            "model_id": self.model_id,
            "glyph_trace": self.glyph_trace,
            "name": self.config.get("worker_name", "Worker"),
            "status": "alive",
            "version": "1.0.0",
            "last_seen": time.time(),
            "vault_integrity": self._check_vault_integrity()
        }

        registry_endpoint = self.config.get("dals_registry_endpoint")
        if registry_endpoint:
            async with httpx.AsyncClient(timeout=10.0) as client:
                try:
                    response = await client.post(registry_endpoint, json=payload)
                    if response.status_code == 200:
                        print(f"[{self.serial}] Heartbeat OK")
                    else:
                        print(f"Registry rejected: {response.status_code}")
                except Exception as e:
                    print(f"Registry unreachable: {e}")

    def _check_vault_integrity(self) -> bool:
        """Check if vault references are properly set"""
        return all([
            bool(self.accountability_vault),
            bool(self.reflection_vault),
            bool(self.glyph_trace),
            bool(self.ap_helix_ref)
        ])

    def inject_pem_engine(self, pem_engine):
        """Inject PEM engine (called by DALS)"""
        self.pem_engine = pem_engine

    def get_app(self) -> FastAPI:
        """Get the FastAPI application instance"""
        return self.app