apiVersion: v1
kind: ServiceAccount
metadata:
  name: caleon-metrics-adapter
  namespace: caleon-prime
  labels:
    app: caleon-prime
    component: custom-metrics
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: caleon-metrics-reader
  labels:
    app: caleon-prime
    component: custom-metrics
rules:
- apiGroups: ["custom.metrics.k8s.io"]
  resources: ["*"]
  verbs: ["*"]
- apiGroups: ["external.metrics.k8s.io"]
  resources: ["*"]
  verbs: ["*"]
- apiGroups: [""]
  resources: ["pods", "services"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: caleon-metrics-binding
  labels:
    app: caleon-prime
    component: custom-metrics
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: caleon-metrics-reader
subjects:
- kind: ServiceAccount
  name: caleon-metrics-adapter
  namespace: caleon-prime
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: caleon-custom-metrics-adapter
  namespace: caleon-prime
  labels:
    app: caleon-prime
    component: custom-metrics
spec:
  replicas: 1
  selector:
    matchLabels:
      app: caleon-prime
      component: custom-metrics
  template:
    metadata:
      labels:
        app: caleon-prime
        component: custom-metrics
    spec:
      serviceAccountName: caleon-metrics-adapter
      containers:
        - name: adapter
          image: registry.caleon.ai/custom-metrics-adapter:latest
          imagePullPolicy: Always
          ports:
            - containerPort: 8080
              name: http
          env:
            - name: CALEON_ENDPOINT
              value: "http://caleon-prime-service.caleon-prime.svc.cluster.local:8003"
            - name: METRICS_UPDATE_INTERVAL
              value: "30s"
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 256Mi
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /ready
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 1000
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
---
apiVersion: v1
kind: Service
metadata:
  name: caleon-custom-metrics
  namespace: caleon-prime
  labels:
    app: caleon-prime
    component: custom-metrics
spec:
  selector:
    app: caleon-prime
    component: custom-metrics
  ports:
    - name: http
      port: 8080
      targetPort: 8080
      protocol: TCP
  type: ClusterIP
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: caleon-metrics-config
  namespace: caleon-prime
  labels:
    app: caleon-prime
    component: custom-metrics
data:
  metrics-adapter.py: |
    #!/usr/bin/env python3
    """
    Caleon Prime Custom Metrics Adapter
    Provides voice_load and cans_risk_score metrics to HPA
    """

    import os
    import json
    import time
    from flask import Flask, jsonify, Response
    import requests
    import logging

    app = Flask(__name__)
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    CALEON_ENDPOINT = os.getenv('CALEON_ENDPOINT', 'http://caleon-prime-service.caleon-prime.svc.cluster.local:8003')

    class CaleonMetricsAdapter:
        def __init__(self):
            self.caleon_endpoint = CALEON_ENDPOINT
            self.cache = {}
            self.cache_ttl = 30  # seconds

        def get_caleon_status(self):
            """Get status from Caleon Prime API"""
            try:
                response = requests.get(f"{self.caleon_endpoint}/api/v1/caleon/status", timeout=5)
                if response.status_code == 200:
                    return response.json()
                else:
                    logger.warning(f"Caleon status returned {response.status_code}")
                    return {}
            except Exception as e:
                logger.error(f"Failed to get Caleon status: {e}")
                return {}

        def get_voice_load(self):
            """Get current voice processing load"""
            status = self.get_caleon_status()
            voice_status = status.get('voice_awareness', {})

            # Calculate load based on active streams and processing queue
            active_streams = voice_status.get('active_streams', 0)
            queued_requests = voice_status.get('queued_requests', 0)
            processing_capacity = voice_status.get('processing_capacity', 100)

            # Load calculation: (active + queued) / capacity * 100
            total_load = active_streams + queued_requests
            load_percentage = min((total_load / max(processing_capacity, 1)) * 100, 200)  # Cap at 200%

            return load_percentage

        def get_cans_risk_score(self):
            """Get CANS autonomic risk assessment"""
            status = self.get_caleon_status()
            cans_status = status.get('cans_autonomic', {})

            # Risk score from 0-100 (0 = no risk, 100 = critical)
            risk_score = cans_status.get('current_risk_score', 0)

            # Ensure it's within bounds
            return max(0, min(100, risk_score))

        def get_metric_value(self, metric_name, namespace, pod_name=None):
            """Get metric value for HPA"""
            current_time = time.time()

            # Check cache
            cache_key = f"{metric_name}:{namespace}:{pod_name}"
            if cache_key in self.cache:
                cached_time, value = self.cache[cache_key]
                if current_time - cached_time < self.cache_ttl:
                    return value

            # Calculate metric
            if metric_name == 'voice_load':
                value = self.get_voice_load()
            elif metric_name == 'cans_risk_score':
                value = self.get_cans_risk_score()
            else:
                value = 0

            # Cache result
            self.cache[cache_key] = (current_time, value)

            return value

    adapter = CaleonMetricsAdapter()

    @app.route('/health')
    def health():
        return jsonify({"status": "healthy"})

    @app.route('/ready')
    def ready():
        return jsonify({"status": "ready"})

    @app.route('/apis/custom.metrics.k8s.io/v1beta1')
    def apis():
        return jsonify({
            "kind": "APIResourceList",
            "apiVersion": "v1",
            "groupVersion": "custom.metrics.k8s.io/v1beta1",
            "resources": []
        })

    @app.route('/apis/custom.metrics.k8s.io/v1beta1/namespaces/<namespace>/pods/*/voice_load')
    def get_voice_load_metric(namespace):
        value = adapter.get_metric_value('voice_load', namespace)
        return jsonify({
            "kind": "MetricValueList",
            "apiVersion": "custom.metrics.k8s.io/v1beta1",
            "metadata": {
                "selfLink": f"/apis/custom.metrics.k8s.io/v1beta1/namespaces/{namespace}/pods/*/voice_load"
            },
            "items": [{
                "describedObject": {
                    "kind": "Pod",
                    "namespace": namespace,
                    "name": "caleon-prime-0",
                    "apiVersion": "v1"
                },
                "metricName": "voice_load",
                "timestamp": time.time(),
                "value": str(int(value * 1000))  # Convert to milliunits
            }]
        })

    @app.route('/apis/custom.metrics.k8s.io/v1beta1/namespaces/<namespace>/pods/*/cans_risk_score')
    def get_cans_risk_metric(namespace):
        value = adapter.get_metric_value('cans_risk_score', namespace)
        return jsonify({
            "kind": "MetricValueList",
            "apiVersion": "custom.metrics.k8s.io/v1beta1",
            "metadata": {
                "selfLink": f"/apis/custom.metrics.k8s.io/v1beta1/namespaces/{namespace}/pods/*/cans_risk_score"
            },
            "items": [{
                "describedObject": {
                    "kind": "Pod",
                    "namespace": namespace,
                    "name": "caleon-prime-0",
                    "apiVersion": "v1"
                },
                "metricName": "cans_risk_score",
                "timestamp": time.time(),
                "value": str(int(value * 1000))  # Convert to milliunits
            }]
        })

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=8080, debug=False)